to show-tree-populations-info ; Procédure pour afficher les populations d'arbres
                              ; Compter le nombre total de populations d'arbres
  let total-populations count tree-populations
  show (word "Nombre total de populations d'arbres : " total-populations)

  ; Vérifier si le nombre total est bien de 24
  ifelse total-populations = 24 [
    show "Le modèle a correctement 24 populations d'arbres."
  ] [
    show (word "ATTENTION : Le modèle n'a que " total-populations " populations d'arbres.")
  ]

  ; Parcourir chaque patch contenant des populations d'arbres
  ask patches with [any? tree-populations-here] [
    ; Compter le nombre de populations d'arbres sur ce patch
    let pop-count count tree-populations-here
    ; Afficher les informations pour ce patch
    show (word "Patch (" pxcor ", " pycor "): " pop-count " populations.")

    ; Itérer sur chaque population d'arbres et afficher les détails
    ask tree-populations-here with [current-leaf-stock < 0 or current-fruit-stock < 0] [
      show (word "  Type d'arbre: " tree-type
        ", Âge: " tree-pop-age
        ", Taille de la population: " population-size
        ", Stock max de bois" max-wood-stock
        ", Stock actuel de bois" current-wood-stock
        ", Stock max de fruits" max-fruit-stock
        ", Stock actuel de fruits" current-fruit-stock
        ", Stock max de feuilles" max-leaf-stock
        ", Stock actuel de feuilles" current-leaf-stock)
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Initialisation des arbres ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to setup-trees ; Valeurs d'initialisation (âge minimum des arbres découverts)
  ask patches [
    ; Liste des types d'arbres à traiter
    ; Si le nombre d'arbres est supérieur à 0, procéder à l'initialisation
    if num-nutritious > 0 [
      let input-tree-type "nutritive"

      ; Répartir la population en groupes d'âge
      let age-distribution split-population num-nutritious
      let num-ages length age-distribution
      let indices range length age-distribution

      ; Boucle sur les âges
      foreach indices [ [i]->
        let pop-size item i age-distribution
        let tree-age ifelse-value (i < 7) [i + 1] [8]
        ; Obtenir les données pour ce type d'arbre et cet âge
        let age-data get-age-data input-tree-type tree-age
        if age-data != [] [
          ; Extraire les valeurs de stocks et de sensibilité
          let max-fruit item 0 age-data
          let max-leaf item 1 age-data
          let max-wood item 2 age-data
          let sensitivity item 3 age-data
          ; Stocker les valeurs dans les variables de patch
          set intermediate-patch-pop-size pop-size
          set intermediate-patch-tree-age tree-age
          set intermediate-patch-tree-type input-tree-type
          set init-patch-max-fruit-stock max-fruit * pop-size
          set init-patch-max-leaf-stock max-leaf * pop-size
          set init-patch-max-wood-stock max-wood * pop-size
          set init-patch-sensitivity sensitivity

          ; Créer une population d'arbres sur le patch
          sprout-tree-populations 1 [
            set tree-type intermediate-patch-tree-type
            set tree-pop-age intermediate-patch-tree-age
            set population-size intermediate-patch-pop-size

            ifelse population-size = 0 [
              ; Si la population est nulle, définir toutes les ressources à zéro
              set current-wood-stock 0
              set current-fruit-stock 0
              set current-leaf-stock 0
              set max-wood-stock 0
              set max-fruit-stock 0
              set max-leaf-stock 0
              hide-turtle
            ] [
              ; Initialiser les stocks actuels
              set max-fruit-stock init-patch-max-fruit-stock
              set max-leaf-stock init-patch-max-leaf-stock
              set max-wood-stock init-patch-max-wood-stock
              set current-fruit-stock (max-fruit-stock / 2)
              set current-leaf-stock (max-leaf-stock / 2)
              set current-wood-stock max-wood-stock
              set tree-sensitivity init-patch-sensitivity
              let nutritive-nutritional-values get-tree-nutritional-values tree-type [soil-type] of patch-here current-season
              set tree-UF-per-kg-MS item 0 nutritive-nutritional-values
              set tree-MAD-per-kg-MS item 1 nutritive-nutritional-values

              hide-turtle
            ]
          ]
        ]
      ]
    ]


    if num-less-nutritious > 0 [
      ; Répartir la population en groupes d'âge*
      let input-tree-type "lessNutritive"
      let age-distribution split-population num-less-nutritious
      let num-ages length age-distribution
      let indices range length age-distribution
      ; Boucle sur les âges
      foreach indices [ [i]->
        let pop-size item i age-distribution
        let tree-age ifelse-value (i < 7) [i + 1] [8]
        ; Obtenir les données pour ce type d'arbre et cet âge
        let age-data get-age-data input-tree-type tree-age

        ; Vérifier si les données pour cet âge existent
        if age-data != [] [
          ; Extraire les valeurs de stocks et de sensibilité
          let max-fruit item 0 age-data
          let max-leaf item 1 age-data
          let max-wood item 2 age-data
          let sensitivity item 3 age-data

          ; Stocker les valeurs dans les variables de patch
          set intermediate-patch-pop-size pop-size
          set intermediate-patch-tree-age tree-age
          set intermediate-patch-tree-type input-tree-type
          set init-patch-max-fruit-stock max-fruit * pop-size
          set init-patch-max-leaf-stock max-leaf * pop-size
          set init-patch-max-wood-stock max-wood * pop-size
          set init-patch-sensitivity sensitivity


          ; Créer une population d'arbres sur le patch
          sprout-tree-populations 1 [
            set tree-type intermediate-patch-tree-type
            set tree-pop-age intermediate-patch-tree-age
            set population-size intermediate-patch-pop-size

            ifelse population-size = 0 [
              ; Si la population est nulle, définir toutes les ressources à zéro
              set current-wood-stock 0
              set current-fruit-stock 0
              set current-leaf-stock 0
              set max-wood-stock 0
              set max-fruit-stock 0
              set max-leaf-stock 0
              hide-turtle
            ] [
              ; Initialiser les stocks actuels
              set max-fruit-stock init-patch-max-fruit-stock
              set max-leaf-stock init-patch-max-leaf-stock
              set max-wood-stock init-patch-max-wood-stock
              set current-fruit-stock (max-fruit-stock / 2)
              set current-leaf-stock (max-leaf-stock / 2)
              set current-wood-stock max-wood-stock
              set tree-sensitivity init-patch-sensitivity
              let nutritive-nutritional-values get-tree-nutritional-values tree-type [soil-type] of patch-here current-season
              set tree-UF-per-kg-MS item 0 nutritive-nutritional-values
              set tree-MAD-per-kg-MS item 1 nutritive-nutritional-values

              hide-turtle
            ]
          ]
        ]
      ]
    ]


    if num-fruity > 0 [
      let input-tree-type "fruity"
      ; Répartir la population en groupes d'âge
      let age-distribution split-population num-fruity
      let num-ages length age-distribution
      let indices range length age-distribution
      ; Boucle sur les âges
      foreach indices [ [i]->
        let pop-size item i age-distribution
        let tree-age ifelse-value (i < 7) [i + 1] [8]

        ; Obtenir les données pour ce type d'arbre et cet âge
        let age-data get-age-data input-tree-type tree-age

        ; Vérifier si les données pour cet âge existent
        if age-data != [] [
          ; Extraire les valeurs de stocks et de sensibilité
          let max-fruit item 0 age-data
          let max-leaf item 1 age-data
          let max-wood item 2 age-data
          let sensitivity item 3 age-data

          ; Stocker les valeurs dans les variables de patch
          set intermediate-patch-pop-size pop-size
          set intermediate-patch-tree-age tree-age
          set intermediate-patch-tree-type input-tree-type
          set init-patch-max-fruit-stock max-fruit * pop-size
          set init-patch-max-leaf-stock max-leaf * pop-size
          set init-patch-max-wood-stock max-wood * pop-size
          set init-patch-sensitivity sensitivity


          ; Créer une population d'arbres sur le patch
          sprout-tree-populations 1 [
            set tree-type intermediate-patch-tree-type
            set tree-pop-age intermediate-patch-tree-age
            set population-size intermediate-patch-pop-size

            ifelse population-size = 0 [
              ; Si la population est nulle, définir toutes les ressources à zéro
              set current-wood-stock 0
              set current-fruit-stock 0
              set current-leaf-stock 0
              set max-wood-stock 0
              set max-fruit-stock 0
              set max-leaf-stock 0
              hide-turtle
            ] [
              ; Initialiser les stocks actuels
              set max-fruit-stock init-patch-max-fruit-stock
              set max-leaf-stock init-patch-max-leaf-stock
              set max-wood-stock init-patch-max-wood-stock
              set current-fruit-stock (max-fruit-stock / 2)
              set current-leaf-stock (max-leaf-stock / 2)
              set current-wood-stock max-wood-stock
              set tree-sensitivity init-patch-sensitivity
              let nutritive-nutritional-values get-tree-nutritional-values tree-type [soil-type] of patch-here current-season
              set tree-UF-per-kg-MS item 0 nutritive-nutritional-values
              set tree-MAD-per-kg-MS item 1 nutritive-nutritional-values

              hide-turtle
            ]
          ]
        ]
      ]
    ]
    let mature-tree-populations tree-populations-here with [tree-pop-age >= 8]
    if any? mature-tree-populations [
      let total-population sum [population-size] of mature-tree-populations
      ;; Créer une tortue pour représenter les arbres matures
      sprout-mature-tree-pops 1 [
        set shape "tree"
        set color green
        set size calculate-tree-icon-size total-population  ;; Taille proportionnelle à la population
                                                            ;; Positionner la tortue au centre du patch avec un décalage aléatoire
        set xcor xcor + (random-float 0.9 - 0.45)
        set ycor ycor + (random-float 0.9 - 0.45)
      ]
    ]
  ]

end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Mise à jour des valeurs nutritives des arbres. Mise à jour par saison ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to update-tree-nutritional-values
  ask tree-populations [
    let nutritional-values get-tree-nutritional-values tree-type [soil-type] of patch-here current-season
    set tree-UF-per-kg-MS item 0 nutritional-values
    set tree-MAD-per-kg-MS item 1 nutritional-values
  ]
end


to update-tree-visualisation
  ;; Supprimer les anciennes icônes
  ask mature-tree-pops [ die ]
  ;; Créer de nouvelles icônes pour les arbres matures
  ask patches [
    let mature-tree-populations tree-populations-here with [tree-pop-age >= 8]
    if any? mature-tree-populations [
      let total-population sum [population-size] of mature-tree-populations
      sprout-mature-tree-pops 1 [
        set shape "tree"
        set color green
        set size calculate-tree-icon-size total-population
        set xcor xcor + (random-float 0.9 - 0.45)
        set ycor ycor + (random-float 0.9 - 0.45)
      ]
    ]
  ]
end


to update-tree-age
  ; Si une année s'est écoulée
  let advancing-populations []
  ; 2. Incrémenter l'âge de toutes les populations d'arbres
  ask tree-populations [
    if tree-pop-age < 8 [
      set tree-pop-age tree-pop-age + 1
      ; Mettre à jour les stocks maximaux pour le nouvel âge
      let age-data get-age-data tree-type tree-pop-age
      let max-fruit item 0 age-data
      let max-leaf item 1 age-data
      let max-wood item 2 age-data
      let sensitivity item 3 age-data
      ifelse population-size > 0 [
        set max-wood-stock max-wood * population-size
        set max-fruit-stock max-fruit * population-size
        set max-leaf-stock max-leaf * population-size
      ] [
        set max-wood-stock 0
        set max-fruit-stock 0
        set max-leaf-stock 0
      ]
        set tree-sensitivity sensitivity

      if tree-pop-age = 8 and population-size > 0 [
        set advancing-populations lput (list patch-here tree-type population-size current-fruit-stock current-leaf-stock current-wood-stock) advancing-populations
        die
      ]
    ]
  ]

  ; Traiter les populations avancées

  foreach advancing-populations [ any-adv-population ->
    let adv-patch item 0 any-adv-population
    let adv-tree-type item 1 any-adv-population
    let adv-pop-size item 2 any-adv-population
    let adv-fruit-stock item 3 any-adv-population
    let adv-leaf-stock item 4 any-adv-population
    let adv-wood-stock item 5 any-adv-population
    let existing-population one-of tree-populations with [
      patch-here = adv-patch and tree-type = adv-tree-type and tree-pop-age = 8
    ]
    ifelse existing-population != nobody [
      ; Ajouter la taille de la population qui passe à l'âge 8
      ask existing-population [
        set population-size population-size + adv-pop-size
        ; Mettre à jour les stocks maximaux
        let age-data get-age-data tree-type tree-pop-age
        let max-fruit item 0 age-data
        let max-leaf item 1 age-data
        let max-wood item 2 age-data
        set max-wood-stock max-wood * population-size
        set max-fruit-stock max-fruit * population-size
        set max-leaf-stock max-leaf * population-size

        set current-fruit-stock current-fruit-stock + adv-fruit-stock
        set current-leaf-stock current-leaf-stock + adv-leaf-stock
        set current-wood-stock current-wood-stock + adv-wood-stock
        ; Mettre à jour les stocks actuels si nécessaire
      ]


    ] [
      ; Créer une nouvelle population d'arbres à l'âge 8
      ask adv-patch [
        sprout-tree-populations 1 [
          set tree-type adv-tree-type
          set tree-pop-age 8
          set population-size adv-pop-size
          ; Initialiser les stocks
          let age-data get-age-data tree-type tree-pop-age
          let max-fruit item 0 age-data
          let max-leaf item 1 age-data
          let max-wood item 2 age-data
          set max-fruit-stock item 0 max-fruit * population-size
          set max-leaf-stock item 1 max-leaf * population-size
          set max-wood-stock item 2 max-wood  * population-size
          ; Initialiser les stocks actuels
          set current-fruit-stock adv-fruit-stock
          set current-leaf-stock adv-leaf-stock
          set current-wood-stock adv-wood-stock
          hide-turtle
        ]
      ]
    ]
  ]
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Création de nouvelles populations d'arbres d'un an ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to renew-tree-population
  let total-new-trees 0
  ; Cette procédure sera appelée uniquement en Nduungu une fois par saison
  ask patches [
    let new-trees-by-type []

    ; Calculer le nombre de nouvelles pousses pour chaque type d'arbre sur le patch
    ask tree-populations-here [
      ; Récupérer le taux de germination pour le type d'arbre et la qualité de l'année
      let germination-rate get-germination-rate tree-type current-year-type
      ; Calculer les nouvelles pousses
      let new-trees floor ((current-fruit-stock * 100 ) * germination-rate)
      set new-trees min (list new-trees [max-tree-number] of patch-here)

      ; Ajouter les nouvelles pousses au total pour ce type d'arbre
      let current-type-entry filter [x -> item 0 x = tree-type] new-trees-by-type
      ifelse length current-type-entry > 0 [
        ; Si le type existe déjà, additionner les nouvelles pousses à la quantité existante
        let existing-entry first current-type-entry
        set new-trees-by-type replace-item (position existing-entry new-trees-by-type) new-trees-by-type
        (list tree-type (item 1 existing-entry + new-trees))
      ] [
        ; Sinon, créer une nouvelle entrée pour ce type d'arbre
        set new-trees-by-type lput (list tree-type new-trees) new-trees-by-type
      ]
    ]

    ; Créer de nouvelles populations d'arbres pour chaque type d'arbre en fonction des nouvelles pousses calculées
    foreach new-trees-by-type [ [type-and-count] ->
      let new-tree-type item 0 type-and-count
      let number item 1 type-and-count
      if number > 0 [
        sprout-tree-populations 1 [
          set tree-type new-tree-type
          set tree-pop-age 1
          set population-size number
          ; Initialiser les stocks actuels
          let age-data get-age-data tree-type tree-pop-age
          set max-fruit-stock item 0 age-data * population-size
          set max-leaf-stock item 1 age-data * population-size
          set max-wood-stock item 2 age-data * population-size
          set current-fruit-stock (max-fruit-stock / 2)
          set current-leaf-stock (max-leaf-stock / 2)
          set current-wood-stock max-wood-stock
          set tree-sensitivity item 3 age-data
          let nutritional-values get-tree-nutritional-values tree-type [soil-type] of patch-here current-season
          set tree-UF-per-kg-MS item 0 nutritional-values
          set tree-MAD-per-kg-MS item 1 nutritional-values
          hide-turtle
        ]
      ]
    ]
  ]
end



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Croissance des stocks des ressources des arbres ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to grow-tree-resources
  ask tree-populations with [population-size > 0] [
    let age-data get-age-data tree-type tree-pop-age
    let max-fruit item 0 age-data
    let max-leaf item 1 age-data
    let max-wood item 2 age-data
    set max-wood-stock max-wood * population-size

    ; Réactualiser le max de bois en fonction de la population restante


    ; Croissance ou décroissance logistique du bois
    let wood-growth growth-wood-logistic tree-type current-wood-stock max-wood-stock current-season

    let new-wood-stock current-wood-stock + wood-growth
    set current-wood-stock min (list new-wood-stock max-wood-stock)
    if current-wood-stock < 0.4 * max-wood-stock [
      set current-wood-stock (0.4 * max-wood-stock)]

    ; Ratio de bois par population
    set wood-ratio calculate-wood-ratio

    ; Réactualiser le max de fruits et feuilles  en fonction de la population restante et du bois
    set max-fruit-stock max-fruit * population-size * wood-ratio
    set max-leaf-stock max-leaf * population-size * wood-ratio

    ; Croissance ou décroissance logistique des fruits
    let fruit-growth growth-fruit-logistic tree-type current-fruit-stock max-fruit-stock current-season ([soil-type] of patch-here)
    let new-fruit-stock current-fruit-stock + fruit-growth
    set current-fruit-stock min (list new-fruit-stock max-fruit-stock)
    if current-fruit-stock <= 0 [set current-fruit-stock 1 ]

    ; Croissance ou décroissance logistique des feuilles
    let leaf-growth growth-leaf-logistic tree-type current-leaf-stock max-leaf-stock current-season ([soil-type] of patch-here)
    let new-leaf-stock current-leaf-stock + leaf-growth
    set current-leaf-stock min (list new-leaf-stock max-leaf-stock)
    if current-leaf-stock <= 0 [set current-leaf-stock 1 ]
  ]
  ask tree-populations with [population-size <= 0] [die]

end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Ouverture des fichiers pour les stocks et la sensibilité des arbres selon leur type et l'age ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to load-tree-age-data [filename]
  set tree-age-table table:make
  file-open filename
  ; Lire les données ligne par ligne
  while [not file-at-end?] [
    let line csv:from-row file-read-line
    ; Convertir les éléments en types appropriés
    let trees-type item 0 line        ; "nutritive", "lessNutritive", "fruity"
    let ages item 1 line ; Âge (1 à 8)
    let max-fruits item 2 line
    let max-leaves item 3 line
    let max-woods item 4 line
    let sensitivities item 5 line
    ; Ajouter les données à la table `tree-age-table`
    table:put tree-age-table (list trees-type ages) (list max-fruits max-leaves max-woods sensitivities)
  ]
  file-close
end




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Ouverture des fichiers pour les valeurs nutritionnelles selon leur type, le type de sol et la saison ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

to load-tree-nutrition-data [filename]
  set tree-nutrition-table table:make
  file-open filename
  ; Lire les données ligne par ligne
  while [not file-at-end?] [
    let line csv:from-row file-read-line
    ; Convertir les éléments en types appropriés
    let trees-type item 0 line        ; "nutritive", "lessNutritive", "fruity"
    let landscapes item 1 line ; "Baldiol", "Sangre", "Seeno", "Caangol"
    let seasons item 2 line
    let tree-UF-data item 3 line
    let tree-MAD-data item 4 line
    ; Ajouter les données à la liste `tree-nutrition-data`
    table:put tree-nutrition-table (list trees-type landscapes seasons) (list tree-UF-data tree-MAD-data)
  ]
  file-close
end


; Fonctions pour calculer les populations initiales en fonction du type d'arbre, de l'âge et de la taille de la population
to-report get-age-data [trees-type ages]
  ; On vérifie si la clé existe dans la table
  ifelse table:has-key? tree-age-table (list trees-type ages) [
    report table:get tree-age-table (list trees-type ages)
  ] [
    ; Si aucune donnée trouvée, retourner des valeurs par défaut
    report (list 0 0 0 0)
  ]
end



to-report get-tree-nutritional-values [trees-type soil season]
  ; Parcourir la structure `tree-nutritional-values` pour trouver les valeurs correspondantes
  ifelse table:has-key? tree-nutrition-table (list trees-type soil season) [
    report table:get tree-nutrition-table (list trees-type soil season)
  ] [
    report (list 0 0) ; Valeurs par défaut si introuvable
  ]

end



to-report split-population [total-population]
  let age-groups []

  ; Calculer la population pour l'âge 8 (80% du total)
  let age8-population round (total-population * 0.8)

  ; Calculer la population restante à répartir entre les âges 1 à 7
  let remaining-population total-population - age8-population

  ; Nombre d'âges pour la répartition restante (1 à 7)
  let num-younger-ages 7

  ; Répartition uniforme de la population restante
  let base-population round (remaining-population / num-younger-ages)
  let leftover remaining-population mod num-younger-ages

  ; Initialiser la liste des groupes d'âge pour les âges 1 à 7
  repeat num-younger-ages [
    set age-groups lput base-population age-groups
  ]

  ; Distribuer le reste sur les premiers âges
  if leftover > 0 [
    let i 0
    while [i < leftover] [
      set age-groups replace-item i age-groups ((item i age-groups) + 1)
      set i i + 1
    ]
  ]
  ; Ajouter la population de l'âge 8 à la fin de la liste
  set age-groups lput age8-population age-groups
  ; La liste `age-groups` contient maintenant les populations pour les âges 1 à 8
  ; Index 0 correspond à l'âge 1, index 7 correspond à l'âge 8
  report age-groups
end




to-report calculate-wood-ratio

  ifelse max-wood-stock <= 0 [
    report 1  ; Éviter la division par zéro
  ] [
    report current-wood-stock / max-wood-stock
  ]
end

to-report calculate-tree-icon-size [populations]
  ;; Définir les valeurs minimales et maximales pour le mapping
  let minPopulation 0
  let maxPopulation 8000  ;; Ajustez cette valeur en fonction de vos données réelles
  let minSize 0.1
  let maxSize 1.5
  ;; Assurer que population est dans les limites
  let adjusted-population max list minPopulation (min list populations maxPopulation)
  report minSize + ((adjusted-population - minPopulation) / (maxPopulation - minPopulation)) * (maxSize - minSize)
end


; Obtenir le taux de germination en fonction du type d'arbre et de la qualité de l'année
to-report get-germination-rate [tree-types year-type]
  let rate 0
  if tree-types
  = "nutritive" [
    if year-type = "bonne" [set rate 0.2]
    if year-type = "moyenne" [set rate 0.05]
    if year-type = "mauvaise" [set rate 0.01]
  ]
  if tree-type = "lessNutritive" [
    if year-type = "bonne" [set rate 0.15]
    if year-type = "moyenne" [set rate 0.08]
    if year-type = "mauvaise" [set rate 0.01]
  ]
  if tree-type = "fruity" [
    if year-type = "bonne" [set rate 0.25]
    if year-type = "moyenne" [set rate 0.15]
    if year-type = "mauvaise" [set rate 0.01]
  ]
  report rate
end




; Fonction pour calculer la croissance logistique des fruits
to-report growth-fruit-logistic [input-tree-type current-fruit max-fruit season landscape]
  let r 0
  ifelse  max-fruit <= 0.0001 [
    report 0  ; Pas de croissance si max-wood est zéro
  ] [
    if input-tree-type = "nutritive" [
      if landscape = "Baldiol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r -0.01]
      ]
      if landscape = "Caangol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Seeno" [
        if season = "Nduungu" [set r 0.1]
        if season = "Ceedu" [set r -0.3]
        if season = "Dabbuunde" [set r 0.02]
        if season = "Ceetcelde" [set r -0.005]
      ]
      if landscape = "Sangre" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r -0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
    ]
    if input-tree-type = "lessNutritive" [
      if landscape = "Baldiol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Caangol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Seeno" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Sangre" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
    ]
    if input-tree-type = "fruity" [
      if landscape = "Baldiol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Caangol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.05]
        if season = "Dabbuunde" [set r 0.03]
        if season = "Ceetcelde" [set r -0.05]
      ]
      if landscape = "Seeno" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Sangre" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
    ]

    let growth r * (precision current-fruit 3) * (precision ((max-fruit - current-fruit) / max-fruit) 3)
  if abs(growth) > 1e10 [
    report 0
  ]
    report growth
  ]
end

;Fonction pour calculer la croissance logistique des feuilles
to-report growth-leaf-logistic [input-tree-type current-leaf max-leaf season landscape]
  let r 0
  ifelse  max-leaf <= 0.0001 [
    report 0  ; Pas de croissance si max-wood est zéro
  ] [
    if input-tree-type = "nutritive" [
      if landscape = "Baldiol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Caangol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Seeno" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Sangre" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
    ]
    if input-tree-type = "lessNutritive" [
      if landscape = "Baldiol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Caangol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Seeno" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Sangre" [
        if season = "Nduungu" [set r 0.005]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r -0.01]
        if season = "Ceetcelde" [set r 0.05]
      ]
    ]
    if input-tree-type = "fruity" [
      if landscape = "Baldiol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Caangol" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Seeno" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
      if landscape = "Sangre" [
        if season = "Nduungu" [set r 0.05]
        if season = "Ceedu" [set r -0.03]
        if season = "Dabbuunde" [set r 0.01]
        if season = "Ceetcelde" [set r 0.005]
      ]
    ]
    let growth r * (precision current-leaf 3) * (precision ((max-leaf - current-leaf) / max-leaf) 3)
    if abs(growth) > 1e10 [
      report 0
    ]
    report growth
  ]

end

;Fonction pour calculer la croissance logistique du bois
to-report growth-wood-logistic [input-tree-type current-wood max-wood season]
  let r 0
  ifelse  max-wood = 0 [
    report 0  ; Pas de croissance si max-wood est zéro
  ] [
    if input-tree-type = "nutritive" [
      if season = "Nduungu" [set r 0.001]
      if season = "Ceedu" [set r 0.003]
      if season = "Dabbuunde" [set r 0.00001]
      if season = "Ceetcelde" [set r 0.00001]
    ]
    if input-tree-type = "lessNutritive" [
      if season = "Nduungu" [set r 0.004]
      if season = "Ceedu" [set r 0.002]
      if season = "Dabbuunde" [set r 0.00001]
      if season = "Ceetcelde" [set r 0.00001]
    ]
    if input-tree-type = "fruity" [
      if season = "Nduungu" [set r 0.006]
      if season = "Ceedu" [set r 0.004]
      if season = "Dabbuunde" [set r 000002]
      if season = "Ceetcelde" [set r 0.00001]
    ]

    let growth r * (precision current-wood 3) * (precision ((max-wood - current-wood) / max-wood) 3)
    if abs(growth) > 1e10 [
      report 0
    ]
    report growth
  ]
end
